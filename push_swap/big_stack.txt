/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   big_stack.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ftomaz-c <ftomaz-c@student.42lisboa.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/09/14 10:16:07 by ftomaz-c          #+#    #+#             */
/*   Updated: 2023/09/16 15:45:17 by ftomaz-c         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

// int	find_pivot(t_list **head)
// {
// 	int		data_sum;
// 	int		count;
// 	t_list	*current;

// 	current = *head;
// 	data_sum = 0;
// 	count = 0;
// 	while (current)
// 	{
// 		data_sum += current->data;
// 		count++;
// 		current = current->next;
// 		if (current == *head)
// 			break;
// 	}
// 	return (data_sum / count);
// }

t_list	*median_of_three(t_list *first,  t_list *middle, t_list *last)
{
	int	a;
	int	b;
	int	c;

	a = first->data;
	b = middle->data;
	c = last->data;
	if ((a <= b && b <= c) || (c <= b && b <= a))
		return middle;
	if ((b <= a && a <= c) || (c <= a && a <= b))
		return first;
	return last;
}

t_list	*find_pivot(int size, t_list *start, t_list *end)
{
	t_list	*current;
	int		count;
	t_list		*first;
	t_list		*last;
	t_list		*middle;

	first = start;
	last = end;
	count = 0;
	current = start;
	while (count < ((size - 1) / 2) - 1)
	{
		current = current->next;
		count++;
	}
	middle = current;
	return(median_of_three(first, middle, last));
}

void	split_stack(int size, t_list *t_pivot, t_list **head_a, t_list **head_b)
{
	int		count;
	t_list	*current;

	count = 0;
	current = *head_a;
	while (count < size)
	{
		if (current->data < t_pivot->data)
		{
			push(PB, head_a, head_b);
			current = *head_a;
		}
		else
		{
			rotate(RA, head_a, head_b);
			current = current->next;
		}
		count++;
	}
}

int	pivot_moves(int size, t_list *t_pivot, t_list **head_a, t_list **head_b)
{
	int	i;
	int	moved;
	int	pivot;

	pivot = t_pivot->data;
	i = 0;
	moved = 0;
	while (i < size)
	{
		if (pivot > (*head_a)->data)
		{
			push(PB, head_a, head_b);
			moved++;
		}
		else if (pivot < (*head_a)->data)
			rotate(RA, head_a, head_b);
		else if (pivot == (*head_a)->data)
		{
			if (pivot > (*head_a)->next->data)
			{
				swap(SA, head_a, head_b);
				push(PB, head_a, head_b);
				moved++;
			}
			else if (pivot < (*head_a)->next->data)
			{
				swap(SA, head_a, head_b);
				rotate(RA, head_a, head_b);
			}
		}
		i++;
	}
	return (moved);
}

void	big_stack(t_list **head_a, t_list **head_b)
{
	int		size;
	t_list	*t_pivot;
	int		bigger;
	int		smaller;

	size = stack_size(*head_a);
	t_pivot = find_pivot(size, *head_a, (*head_a)->prev);
	ft_printf("pivot: %d\n", t_pivot->data);

	split_stack(size, t_pivot, head_a, head_b);

	size = stack_size(*head_a);
	t_pivot = find_pivot(size, *head_a, (*head_a)->prev);
	ft_printf("pivot: %d\n", t_pivot->data);
	// while ((*head_a)->next->data != t_pivot->data)
	// 	rotate(RA, head_a, head_b);
	bigger = 0;
	smaller = 0;
	// while (!is_in_order(*head_a))
	// {
		if ((*head_a)->data > t_pivot->data)
		{
			swap(SA, head_a, head_b);
			while ((*head_a)->data > (*head_a)->next->data)
			{
				swap(SA, head_a, head_b);
				if (t_pivot->data != (*head_a)->data)
					rotate(RA, head_a, head_b);
			}
			if (bigger == 0)
				bigger = (*head_a)->data;
			else if ((*head_a)->data > bigger)
			{
				rotate(RA, head_a, head_b);
				while ((*head_a)->next->data != bigger)
				{
					swap(SA, head_a, head_b);
					rotate(RA, head_a, head_b);
				}
				bigger = (*head_a)->data;
			}
			else if ((*head_a)->data < bigger && bigger != 0)
			{
				while ((*head_a)->next->data < (*head_a)->data)
				{
					swap(SA, head_a, head_b);
					rotate(RA, head_a, head_b);
				}
			}
			if (smaller == 0)
			{
				while ((*head_a)->data != t_pivot->data)
					reverse_rotate(RRA, head_a, head_b);
			}
			else if (smaller != 0)
			{
				while ((*head_a)->data != smaller)
					reverse_rotate(RRA, head_a, head_b);
			}
		}
		else if ((*head_a)->data < t_pivot->data)
		{
			rotate(RA, head_a, head_b);
		}
		// if ((*head_a)->data == t_pivot->data)
		// {
		// 	rotate(RRA, head_a, head_b);
		// }
	// }
}
